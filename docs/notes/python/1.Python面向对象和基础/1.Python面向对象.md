---
title: Python面向对象
createTime: 2025/10/02 15:35:13
permalink: /Python/4y0r1g9k/
---



## 类与对象
python不仅是强类型语言,也是动态类型语言。这意味着: 
- 变量的类型在运行时确定，而不是在编译时
- 变量可以重新赋值为不同类型的值

### 类属性与实例属性
- 类属性是属于类本身的属性，它们在类的所有实例之间共享，通常用于定义与类相关的常量或默认值。
- 实例属性是属于类的特定实例的属性。每个实例都有自己的实例属性，它们通常在__init__方法中定义。
- 类可以访问自身的类属性，但不能访问实例属性

**类属性**
```python
class MyClass:
  class_attribute = "I am a class attribute"

  def __init__(self, instance_attribute):
    self.instance_attribute = instance_attribute

instance = MyClass("I am an instance attribute")
# 可以通过类名或实例访问类属性。
print(MyClass.class_attribute) # 输出: I am a class attribute

# 通过类名修改类属性会影响所有实例。
MyClass.class_attribute = "New class attribute value"
print(instance.class_attribute)  # 输出: New class attribute value
```

**实例属性**
```python
class MyClass:
  def __init__(self, instance_attribute):
    self.instance_attribute = instance_attribute

# 实例属性只能通过实例访问
instance = MyClass("I am an instance attribute")
print(instance.instance_attribute)  # 输出: I am an instance attribute

# 实例属性的修改只影响该特定实例
instance.instance_attribute = "New instance attribute value"
print(instance.instance_attribute)  # 输出: New instance attribute value

# 如果通过实例修改类属性，实际上会创建一个同名的实例属性，而不会修改类属性本身。
instance.class_attribute = "This creates an instance attribute"
print(instance.class_attribute)  # 输出: This creates an instance attribute
print(MyClass.class_attribute)  # 输出: New class attribute value
```
**类属性和实例属性的名称可以相同，但它们是不同的属性**
```python
class MyClass:
  attribute = "Class attribute"

  def __init__(self):
    self.attribute = "Instance attribute"

instance = MyClass()
print(instance.attribute)  # 输出: Instance attribute
print(MyClass.attribute)    # 输出: Class attribute
```
### 对象即类的实例化
```python
class Student:
  name = None
  age = None

  def say_hi(self):
    print(f"hi, I'm {self.name}")
```

### 成员方法
  ```python
  # 成员方法的定义和使用
  def 方法名(self, 形参1, 形参2, ..., 形参n)
    方法体
  ```
  `self`关键字是成员方法定义的时候，必须添加在参数列表中的，它用来表示**对象自身**，在类的成员方法内想要访问当前类的成员变量时，必须使用`self`关键字。<br>
  当我们使用类对象调用方法时，`self`会自动被python传入。
### 构造方法
  构造方法使得在**创建对象**的定义和使用时可以通过传参的形式对属性赋值。
  - 在创建对象时，会自动执行
  - 在创建对象时，将传入的参数自动传递给__init__方法使用
  ```python
  class Student:
    name = None
    age = None

    def __init__(self, name, age):
      self.name = name
      self.age = age

  stu = Student("周轮", 12)
  ```

### 其他内置方法
  - 字符串方法
  ![__str__()](https://raw.githubusercontent.com/AliceSpring123/img/main/面向对象-字符串方法.png)
  - 运算符重载(<,>)
  ![__lt__()](https://raw.githubusercontent.com/AliceSpring123/img/main/面向对象-运算符重载1.png)
  - 运算符重载(<=,>=)
  ![__le__()](https://raw.githubusercontent.com/AliceSpring123/img/main/面向对象-运算符重载2.png)
  - 运算符重载(==)
  ![__eq__()](https://raw.githubusercontent.com/AliceSpring123/img/main/面向对象-运算符重载3.png)


## 封装
封装表示的是，将现实世界事物的**属性**和**行为**移到类中描述为**成员变量**和**成员方法**，从而完成程序对现实世界事物的描述。
现实事物有**不对用户公开的属性和行为**，那么作为现实事物在程序中映射的类，也应该支持，即**私有成员**
### 私有成员变量
  变量名以`__`开头（2个下划线） **对象无法对私有变量赋值，也无法获取到值**。
### 私有成员方法
  方法名以`__`开头（2个下划线） 私有方法**无法直接被对象调用**。
### 私有成员的使用
  ```python
  class Phone:
    __current_voltage = 0.5 # 当前手机运行电压(私有变量)

    def __keep_single_core(self): #私有方法
      print("cpu以单核模式运行")

    def call_by_5g(self):
      if self.__current_voltage >= 1: 
        print("5g通话已开启")
      else:
        self.__keep_singo_core()
        print("电量低，无法开启5g，已开启单核运行省电")
  ```
## 继承
子类可以从父类那里继承已有的属性和方法，同时子类可以添加新的属性或方法，从而使得程序的结构更加灵活和可扩展。
### 使用方式
  ```python
  # 多个父类中，如果有同名的成员，那么从左到右最先继承的成员被保留
  class 类名(父类1, 父类2, 父类3, ..., 父类n):
    类内容体
  
  ```
  ```python
  # iphone基类
  class iphone:
    IMEI = None     # 序列号
    producer = None # 生产商

    def call_by_4g(self):
      print("4g通话")


  class iphone12(iphone):
    face_id = True # 新增面部识别

    def call_by_5g(self):
      print("iphone 12可以5g通话!")
  ```
### 子类重写父类成员
  子类继承父类的成员属性和成员方法后，还可以进行重写。
  ```python
  class Android:
    IMEI = None  # 序列号
    producer = "Google"  # 厂商

    def call_by_5g(self):
      print("Google 5g通话已开启")


  class MIUI(Android):
    producer = "Xiaomi"  # 重写父类的属性

    def call_by_5g(self):  # 重写父类方法
      print("Xiaomi 5g通话已开启")
  ```
### 在子类中调用父类成员
  有两种方法：
  1. 使用`父类名.成员变量`、`父类名.成员方法(self)`调用父类成员
  2. 使用`super()`调用父类成员：
   ```python
   # 使用成员变量
   super().成员变量
   # 使用成员方法
   super().成员方法()
   ``` 
  注意：只可以在**子类内部**调用父类的成员，如果子类重写了父类的成员，那么子类实例化的对象默认是调用子类中的成员。
  
## 多态
  多态指的是同一个方法可以在不同的对象上表现出不同的行为。简单来说，就是“一个接口，多种实现”。常借助抽象类(接口)来实现多态。
### 抽象类(接口)
  - 方法体是空`pass`的方法是抽象方法，含有抽象方法的类称之为抽象类。
  - 抽象类作为父类，定义了一个标准，其中包含的抽象方法要求其子类在定义时必须实现。(即抽象类用来设计标准，子类用来实现标准)
  - 抽象类多用于**顶层设计**，作为一个规范化模板让子类来具体实现。
### 借助抽象类实现多态
  ```python
  # 含有空方法(抽象方法)的父类成为抽象类(接口)
  # 常用于顶层设计
  class Animal:
    def speak(self):
      pass
  # 抽象类的子类必须实现父类中的抽象方法
  class Dog(Animal):
    def speak(self):
      print("汪汪")

  class Cat(Animal):
    def speak(self):
      print("喵喵")

  # ------
  def make_noise(animal: Animal):
  animal.speak()
  
  dog = Dog()
  cat = Cat()

  make_noise(dog) # 输出: 汪汪
  make_noise(cat) # 输出: 喵喵
  ```
  ![多态](https://raw.githubusercontent.com/AliceSpring123/img/main/面向对象-多态.png)



