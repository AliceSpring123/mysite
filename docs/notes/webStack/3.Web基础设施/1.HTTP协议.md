---
title: HTTP协议
createTime: 2025/10/03 13:41:18
permalink: /WebStack/hhjk56dc/
---


## 简介
http协议，即**超文本传输协议**，是用于从万维网服务器传输超媒体文档(如HTML页面、HTML表单、图片、视频等)到本地浏览器的**应用层**协议。<br>

HTTP协议通常运行在TCP协议上，使用端口80，使用TCP而不使用UDP的原因在于打开一个网页必须传送很多数据，而TCP协议提供传输控制，可以按顺序组织数据和错误纠正。<br>

客户端与服务端之间通过交换一个个独立的消息（而非数据流）进行通信。客户端发出的消息被称作**请求(request)**，服务器的应答被称为**响应(response)**。<br>

![](https://raw.githubusercontent.com/AliceSpring123/img/main/http_layers.png)

## 主要特点
1. **基于请求/响应模型**： 请求和相应必须成对，先有请求后有响应。
2. **简约**：HTTP 被设计得简单且易读，对于开发和测试十分友好。
3. **可扩展**：客户端与服务器之间通过约定**header**的语义，可以扩展新功能。
4. **无状态**：HTTP对事物处理没有记忆能力，先前输入的帐号密码在重新请求网页后就消失了。要想在不同请求中持续访问某些状态，需使用**会话保持技术**。
5. **短连接/长连接**：HTTP/1.0中，client向server发送一个request，得到response后，连接就关闭。HTTP/1.1中改用了长连接，在http请求头中加入`Connection:Keep-Alive`后，server将response返回给client后，不关闭连接。

## HTTP代理
已知请求由客户端发出，但是从客户端到服务器之间还有许多被称为代理的实体，这些代理一般履行如下几种作用：
- 缓存(可以是公开也可以是私有的，如浏览器的缓存)
- 过滤(如反病毒扫描、家长控制)
- 负载均衡(让多个服务器服务不同的请求)
- 认证(控制对不同资源的访问)
- 日志(使得代理可以存储历史信息)

![](https://raw.githubusercontent.com/AliceSpring123/img/main/client-server-chain.svg)

## HTTP报文
HTTP有**请求(request)**和**响应(response)**两种报文类型，每种都有其特定的格式。

### Request报文

常见的请求报文示例：

![](https://raw.githubusercontent.com/AliceSpring123/img/main/http请求报文.jpeg)

1. **请求方法：** 描述了客户端执行的操作，如GET(获取资源)、POST(发送表单)等
2. **请求URL：** 要获取的那个资源的路径。URL中**不包括**协议(`http://`)、域名
3. **HTTP协议及版本：** 描述了HTTP协议版本号
4. **请求头(Header)：** 从第二行开始，到第一个空格结束。请求头通常以{key:value}的方式传递数据，key&value是HTTP请求头中规定好的。
5. **请求体(body)：** 一些像 POST 这样的方法，请求体内包含需要了发送的消息。

### Response报文

常见的响应报文示例：

![](https://raw.githubusercontent.com/AliceSpring123/img/main/http响应报文.jpeg)

1. **报文协议及版本：** 记录了报文协议及版本
2. **状态码及状态描述：** 表明HTTP请求是否成功完成，由HTTP协议事先规定状态码及其含义(也可自定义状态码)。参考状态码及状态描述
3. **响应头：** 提供了关于响应的附加信息和服务器的指令
4. **响应体：** 服务器发送给客户端的正文，即客户端真正需要的"干货"



## 请求头和请求体规范

1. 请求头

| Header | 解释 | 示例 |
| ------ | ---- | ---- |
|Accept|指定客户端能够接收的内容类型，内容类型中的先后次序表示客户端接收的先后次序。	|Accept: text/plain, text/html|
|Accept-Charset	|浏览器可以接受的字符编码集。	|Accept-Charset: gb2312,utf-8;q=0.7,*;q=0.7|
|Accept-Encoding	|指定浏览器可以支持的web服务器返回内容压缩编码类型。	|Accept-Encoding: compress, gzip|
|Accept-Language	|浏览器可接受的语言	|Accept-Language: zh-cn,zh;q=0.5|
|Accept-Ranges	|可以请求网页实体的一个或者多个子范围字段	|Accept-Ranges: bytes|
|Authorization|HTTP授权的授权证书	|Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==|
|Cache-Control	|指定请求和响应遵循的缓存机制	|Cache-Control: no-cache|
|Connection	|表示是否需要持久连接。（HTTP 1.1默认进行持久连接）	|Connection: keep-alive|
|Cookie|HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。	|Cookie: $Version=1; Skin=new;|
|Content-Length	|请求的内容长度	|Content-Length: 348|
|Content-Type	|HTTP请求提交的内容类型。一般只有post提交时才需要设置该属性。	|	Content-Type: application/x-www-form-urlencoded|
|Date|请求发送的日期和时间	|Date: Tue, 15 Nov 2010 08:12:31 GMT|
|Expect	|请求的特定的服务器行为	|Expect: 100-continue|
|From	|发出请求的用户的Email	|From: user@email.com|
|Host|指定请求的服务器的域名和端口号	|Host: www.zcmhi.com|
|If-Match	|只有请求内容与实体相匹配才有效	|If-Match: “737060cd8c284d8af7ad3082f209582d”|
|If-Modified-Since	|如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码	|If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT|
|If-None-Match	|如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变	|If-None-Match: “737060cd8c284d8af7ad3082f209582d”|
|If-Unmodified-Since	|只在实体在指定时间之后未被修改才请求成功	|If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT|
|Max-Forwards	|限制信息通过代理和网关传送的时间	|Max-Forwards: 10|
|Pragma|用来包含实现特定的指令	|Pragma: no-cache|
|Proxy-Authorization	|连接到代理的授权证书	|Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==|
|Range|只请求实体的一部分，指定范围	|Range: bytes=500-999|
|Referer	|先前网页的地址，当前请求网页紧随其后,即来路	|Referer: http://www.zcmhi.com/archives/71.html|
|User-Agent	|User-Agent的内容包含发出请求的用户信息	|User-Agent: Mozilla/5.0 (Linux; X11)|
|Via	|通知中间网关或代理服务器地址，通信协议	|Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)|
|Warning|关于消息实体的警告信息	|Warn: 199 Miscellaneous warning|

> HTTP请求方式：
>   - GET   向服务器请求一个文件
>   - POST  向服务器发送数据让服务器进行处理
>   - PUT   向服务器发送数据让服务器存储
>   - HEAD  检查一个对象是否存在
>   - DELETE    从Web服务器上删除一个文件
>   - CONNECT   对通道提供支持
>   - TRACE     跟踪到服务器的路径
>   - OPTIONS   查询Web服务器的性能


2. 请求体

通常包含表单数据等，如果是传输文件，那么这里就是二进制数据了





## 响应头和响应体规范

1. 响应头

|Header|解释|示例|
|--|--|--|
|Accept-Ranges	|表明服务器是否支持指定范围请求及哪种类型的分段请求	|Accept-Ranges: bytes|
|Age|从原始服务器到代理缓存形成的估算时间（以秒计，非负）	|Age: 12|
|Allow|对某网络资源的有效的请求行为，不允许则返回405	|Allow: GET, HEAD|
|Cache-Control	|告诉所有的缓存机制是否可以缓存及哪种类型	|Cache-Control: no-cache|
|Content-Encoding	|web服务器支持的返回内容压缩编码类型。	|Content-Encoding: gzip|
|Content-Language	|响应体的语言	|Content-Language: en,zh|
|Content-Length	|服务器返回消息正文的长度	|Content-Length: 348|
|Content-Location	|请求资源可替代的备用的另一地址	|Content-Location: /index.html|
|Content-MD5	|返回资源的MD5校验值	|Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==|
|Content-Range	|在整个返回体中本部分的字节位置	|Content-Range: bytes 21010-47021/47022|
|Content-Type	|返回数据的类型（例如text/html文本类型）和字符编码格式。	|Content-Type: text/html; charset=utf-8|
|Date|原始服务器消息发出的时间	|Date: Tue, 15 Nov 2010 08:12:31 GMT|
|ETag|请求变量的实体标签的当前值	|ETag: “737060cd8c284d8af7ad3082f209582d”|
|Expires	|响应过期的日期和时间	|Expires: Thu, 01 Dec 2010 16:00:00 GMT|
|Last-Modified	|请求资源的最后修改时间	|Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT|
|Location|用来重定向接收方到非请求URL的位置来完成请求或标识新的资源	|Location: http://www.zcmhi.com/archives/94.html|
|Pragma|包括实现特定的指令，它可应用到响应链上的任何接收方	|Pragma: no-cache|
|Proxy-Authenticate	|它指出认证方案和可应用到代理的该URL上的参数	|Proxy-Authenticate: Basic|
|refresh|应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）	|Refresh: 5; url=http://www.zcmhi.com/archives/94.html|
|Retry-After	|如果实体暂时不可取，通知客户端在指定时间之后再次尝试	|Retry-After: 120|
|Server|web服务器软件名称	|Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)|
|Set-Cookie	|设置Http Cookie	|Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1|
|Warning|警告实体可能存在的问题	|Warning: 199 Miscellaneous warning|
|Via|告知代理客户端响应是通过哪里发送的	|Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)|
|WWW-Authenticate	|表明客户端请求实体应该使用的授权方案	|WWW-Authenticate: Basic|
|Transfer-Encoding	|文件传输编码	|Transfer-Encoding:chunked|


2. 响应体

服务器返回给客户端的具体内容，如HTML代码、图片文件等




## 响应状态码
状态码有很多种，主要分为五类：1xx, 2xx, 3xx, 4xx, 5xx
- `1xx: 信息响应`

    |状态码|说明|
    |---|--|
    |100 Continue|这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。|
    |101 Switching Protocols|该代码是响应客户端的 Upgrade 请求头发送的，指明服务器即将切换的协议。|
    |102 Processing|此代码表示服务器已收到并正在处理该请求，但当前没有响应可用。|
    |103 Early Hints|此状态代码主要用于与 Link 链接头一起使用，以允许用户代理在服务器准备响应阶段时开始预加载 preloading 资源。|

- `2xx: 成功响应`

    |状态码|说明|
    |--|--|
    |200 OK|请求成功|
    |201 Created|该请求已成功，并因此创建了一个新的资源。这通常是在 POST 请求，或是某些 PUT 请求之后返回的响应。|
    |202 Accepted|请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。|
    |203 Non-Authoritative Information|服务器已成功处理了请求，但返回的信息来自另一个源。|
    |204 No Content|对于该请求没有的内容可发送，但头部字段可能有用。用户代理可能会用此时请求头部信息来更新原来资源的头部缓存字段。|
    |205 Reset Content|告诉客户端重置发送此请求的文档。|
    |226 IM Used (HTTP Delta encoding)|服务器已经完成了对资源的GET请求，并且响应是对当前实例应用的一个或多个实例操作结果的表示。|

- `3xx: 重定向`

    |状态码|说明|
    |--|--|
    |300 Multiple Choice|请求拥有多个可能的响应。服务器可根据user-agent选择，也可以提供列表供客户端选择|
    |301 Moved Permanently|请求资源的 URL 已永久更改。在响应中给出了新的 URL。|
    |302 Found|此响应代码表示所请求资源的 URI 已 暂时 更改。未来可能会对 URI 进行进一步的改变。因此，客户机应该在将来的请求中使用这个相同的 URI。|
    |303 See Other|服务器发送此响应，以指示客户端通过一个 GET 请求在另一个 URI 中获取所请求的资源|
    |308 Permanent Redirect|这意味着资源现在永久位于由HTTP Response Header中`Location: `指定的另一个 URI。|

- `4xx: 客户端错误响应`

    |状态码|说明|
    |--|--|
    |400 Bad Request|客户端错误（例如，错误的请求语法、无效的请求消息帧或欺骗性的请求路由），服务器无法或不会处理请求。|
    |401 Unauthorized|客户端身份认证失败|
    |403 Forbidden|客户端没有访问内容的权限，服务器知道客户端的身份|
    |404 Not Found|服务器找不到请求的资源|
    |405 Method Not Allowed|目标资源不支持客户端当前的请求方法|
    |408 Request Timeout|服务器等待客户端发送的请求时间过长，超时|
    |409 Conflict|PUT请求中可能返回次代码，表示服务器处理PUT请求时发生了冲突|

- `5xx: 服务端错误响应`

    |状态码|说明|
    |--|--|
    |500 Internal Server Error|服务器内部错误，无法完成请求|
    |501 Not Implemented|服务器不支持请求的功能，无法完成请求|
    |502 Bad Gateway|错误网关，作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应|
    |503 Service Unavailable|服务不可用，由于超载或系统维护，服务器暂时无法处理客户端的请求|
    |504 Gateway Timeout|网关超时，充当网关或代理的服务器，未及时从远端服务器获取请求|
    |505 HTTP Version Not Supported|服务器不支持请求的HTTP协议版本|



## HTTP会话管理机制
前面我们提到，HTTP协议是无状态的，当服务器返回应答后，此次事务的所有信息就丢掉了。但现实中我们往往希望一次登陆就可以访问此网站点的各种页面，此时需要**会话保持技术**


### 基于 Cookie + Session 的会话管理机制
1. 名词解释
   - Cookie保存在客户端本地，由服务端生成并发送给浏览器，浏览器会将Cookie的key-value保存到客户端本地，下次请求统一网站时自动发送该Cookie给服务器。
   - Session保存在服务器，客户端访问服务器的时候，服务器把客户端发来的信息写入session比比并保存。
  
2. 实现原理

    当用户第一次通过浏览器使用用户名和密码访问服务器时，服务器会验证用户数据，验证成功后在服务器端写入session数据，向客户端返回sessionid，客户端将sessionid存储在cookie中。

    客户端再次访问服务器时，cookie会被自动发送给服务器，服务器携带cookie中的sessionid查找Session并进行鉴权，鉴权成功则返回客户端需要的数据。

    ![](https://raw.githubusercontent.com/AliceSpring123/img/main/cookie+session.png)

3. 优点分析
   1. 方便管理<br>用户的登录和注销只需要在服务器的内存中添加or删除对应的session就可以

4. 弊端分析
   1. 服务器压力增大。<br>通常session是存储在内存中的，用户量增大时，服务器的压力增大
   2. 扩展性差，session共享麻烦。<br>由于session是存储在内存中的，如果用户第一次访问的是服务器1,当用户再次请求时可能访问的是服务器2,服务器2获取不到sessoin信息，就判定用户需要登陆。
   3. CSRF跨站伪造请求攻击。<br>session是基于cookie进行用户识别的，cookie如果被截获，用户就容易受到跨站请求伪造的攻击。
   4. Cookie的不可跨域名性。<br>Cookie具有不可跨域名性。。浏览器访问Google时只会携带Google的Cookie，而不会携带Baidu的Cookie。浏览器判断一个网站能否操作另一个网站Cookie的依据是域名
   5. 不适应移动端。<br>Session依赖于Cookie，移动端APP没有Cookie，这种机制不适用。

### 基于Token的会话管理机制
1. 实现原理

    客户端使用用户名和密码登录，服务端验证用户名和密码，验证通过后生成Token返回给客户端，客户端用js存储Token并放在Cookie或Local Storage中。
    
    客户端访问服务器时将Token加入到URL参数或Request Header中。

    服务端通过解码Token进行鉴权(没有Token或Token过期，返回401状态码；如果验证成功，就向客户端返回请求的数据)

    客户端得到401状态码，则重定向到登录页面重新登录
2. Token的分类
   1. 访问令牌(Access Token)

        用于访问受保护的资源，通常用于Oauth 2.0 授权框架中。当客户端通过认证服务器获得授权后，会得到一个访问令牌，该令牌可以被发送到资源服务器以获取受保护的资源

   2. 刷新令牌(Refresh Token)：

        用于获取新的访问令牌，通常用于OAuth 2.0 授权框架中。刷新令派可以用来获取新的访问令牌，以避免用户需要重新进行认证流程

   3. JSON Web Token(JWT)

        一种开放标准，用于在各方之间安全地传输信息。JWT通常被用作访问令牌，它包含了被加密的用户信息和其他元数据，可以被用于身份验证和授权

   4. ID令牌(ID Token)

        通常用于OAuth2.0 框架中，用于向客户端提供一认证用户的身份信息。ID令牌通常被用于OpenID Connect协议中

   5. CSRF令牌(Cross-Site Request Forgery Token)

        用于防止跨站请求伪造攻击。CSRF令牌通常是一个随即生成的值，它会被包含在表单提交中，服务器会验证该令牌以确定请求是否合法

