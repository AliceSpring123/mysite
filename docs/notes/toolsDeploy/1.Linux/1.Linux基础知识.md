---
title: Linux基础知识
createTime: 2025/10/02 16:48:36
permalink: /toolsDeploy/weqcuc8v/
---



## Linux第三方学习文档
Linux命令在线速查手册：[[https://www.w3xue.com/manual/linux/](https://www.w3xue.com/manual/linux/)]

另外，[[https://www.shell.how](https://www.shell.how)]这个网站可以用来解释常见命令的含义，对于学习
Linux和其他常用命令(如Git、NPM)非常有益。
## 认识操作系统

### 内核(Kernel)

  摘自维基百科对于内核的解释：

  > 内核(英语：Kernel，又称核心)在计算机科学中是一个用来管理软件发出的数据 I/O(输入与输出)请求的电脑程序，将这些要求转译为数据处理的指令并交由中央处理器（CPU）及电脑中其他电子组件进行处理，是现代操作系统中最基本的部分。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并由内核决定一个程序在什么时候对某部分硬件操作多长时间。 直接对硬件操作是非常复杂的。所以内核通常提供一种硬件抽象的方法，来完成这些操作。有了这个，通过进程间通信机制及系统调用，应用进程可间接控制所需的硬件资源(特别是处理器及 IO 设备) 。

  ​早期计算机系统的设计中，还没有操作系统的内核这个概念。随着计算机系统的发展，操作系统内核的概念才渐渐明晰起来了!

  简单概括就是：

  - 操作系统内核(Kernel)是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。

  - 操作系统的内核是连接软件和硬件的桥梁，它决定着操作系统的性能和稳定性。

### 中央处理器(CPU)

  关于CPU简单概括三点：

  - CPU是一台计算机的运算核心+控制核心，可以称得上是计算机的大脑。

  - CPU主要包括两个部分：控制器+运算器。

  - CPU的根本任务就是执行指令，对于计算机来说最终都是一串由0和1组成的序列。

### CPU vs Kernel

  - 操作系统内核(Kernel)属于操作系统层面，是软件，而CPU属于硬件。(即一个是软件层面的概念，一个是硬件层面的概念)

  - CPU主要提供**运算、处理各种指令**的能力。内核(Kernel)主要负责**系统管理**如内存管理、硬件设备的管理等，它屏蔽了对硬件的操作。

  下图清晰的说明了应用程序、内核、CPU三者的关系：

  ![计算机软硬件之间的关系.png](https://raw.githubusercontent.com/AliceSpring123/img/main/计算机软硬件之间的关系.png)

### 系统调用

  根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：

  - 用户态(user mode)：用户态运行的进程可以直接读取用户程序的数据。

  - 系统态(kernel mode)：系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。

  在我们运行的用户程序中，**凡是与系统态级别的资源有关的操作**(如文件管理、进程控制、内存管理等)，都必须通过**系统调用**的方式向操作系统提出服务请求，由操作系统代为完成。

  这些系统调用按功能大致可分为如下几类：

  | 功能     | 描述                                                         |
  | -------- | ------------------------------------------------------------ |
  | 设备管理 | 完成设备的请求或释放，以及设备启动等功能                     |
  | 文件管理 | 完成文件的读、写、创建及删除等功能                           |
  | 进程控制 | 完成进程的创建、撤销、阻塞及唤醒等功能                       |
  | 进程通信 | 完成进程之间的消息传递或信号传递等功能                       |
  | 内存管理 | 完成内存的分配、回收以及获取作业用内存区大小及地址分配等功能 |

  ![系统调用关系图.png](https://raw.githubusercontent.com/AliceSpring123/img/main/系统调用关系图.png)


## Linux文件系统


### inode介绍

文件在硬盘中有可能被分成多个块(block)来存储，因此是我们需要一个空间来存储文件的元信息（metadata），inode就是用来记录某个文件被分成几块、每块所在的地址、文件拥有者、创建时间、权限、大小等信息。

> inode = i（index）+ node

每个inode都有一个号码，Linux/Unix操作系统不使用文件名来区分文件，而是使用inode号码区分不同文件。

可以使用`stat filename`命令查看文件的`inode`信息

![文件inode命令.png](https://raw.githubusercontent.com/AliceSpring123/img/main/文件inode命令.png)

### Linux文件类型

  Linux支持很多文件类型，其中非常重要的文件类型有：
| 类型        | 描述                                                                           |
| ----------- | ------------------------------------------------------------------------------ |
| 普通文件(-) | 包含纯文本文件、二进制文件和数据文件                                           |
| 目录文件(d) | 类似windows中的文件夹                                                          |
| 链接文件(l) | 类似windows中的快捷方式                                                        |
| 字符设备(c) | 用来访问字符设备比如键盘                                                       |
| 设备文件(b) | 用来访问块设备比如硬盘、软盘                                                   |
| 管道文件(p) | 一种特殊类型的文件，用于进程之间的通信(进程间的通信有两种：匿名管道和有名管道) |

  如下方红框中`drwxr-xr-x`中的d即表示该文件为目录文件。

  ![目录文件示例.png](https://raw.githubusercontent.com/AliceSpring123/img/main/目录文件示例.png)

### Linux目录树结构

  所有可操作的计算机资源都存在于目录树这个结构中，对于计算资源的访问，可以看作是对这棵目录树的访问。Linux的目录结构如下：

  ![Linux目录树.png](https://raw.githubusercontent.com/AliceSpring123/img/main/目录树结构示意图.png)

  常见目录说明：

  | 目录        | 说明                                                                                                                         |
  | ----------- | ---------------------------------------------------------------------------------------------------------------------------- |
  | /           | 超级用户(root)的主目录(特权阶级)。                                                                                           |
  | /bin        | 存放二进制可执行文件(ls, cat, mkdir等)，常用命令一般都在这里。                                                               |
  | /boot       | 存放用于系统引导时使用的各种文件                                                                                             |
  | /dev        | 用于存放设备文件。                                                                                                           |
  | /etc        | 存放系统管理和配置文件。                                                                                                     |
  | **/home**   | 存放所有用户文件的根目录，可以用`～`表示，是用户目录的基点，比如用户user的主目录就是`/home/user`，也可以用`～user`表示。     |
  | /lib        | 存放着和系统运行相关的库文件                                                                                                 |
  | /media      | 媒体文件，即可删除的设备，包括软盘、光盘、DVD等                                                                              |
  | /mnt        | 系统管理员安装临时文件系统的安装点(挂载点)，系统提供这个目录是让用户临时挂载其他的文件系统。                                 |
  | /opt        | 第三方辅助软件存放的目录。一般情况下，我们可以把tomcat等都安装到这里。                                                       |
  | /sbin       | 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序，如`ifconfig`等。               |
  | **/usr**    | UNIX SoftWare Resource，用于存放**操作系统软件资源**的目录，而非用户数据。所有的**系统默认软件**都在此目录。                 |
  | /var        | 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，包括缓存、日志文件以及某些软件运行所产生的程序文件或数据库文件等。 |
  | /proc       | 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。                                                       |
  | /tmp        | 用于存放各种临时文件，是公用的临时文件存储点                                                                                 |
  | /lost+found | 这个目录平时是空的，系统非正常关机而留下"无家可归"的文件(Windows中叫xxx.chk)就在这里。                                       |

### 硬件设备的文件名

在Linux中，每个设备都被当做一个文件来对待；几乎所有的硬件设备文件都存放在`/dev`这个目录内。

| 设备                      | 设备在Linux中的文件名                                                                   |
| ------------------------- | --------------------------------------------------------------------------------------- |
| SCSI、SATA、USB磁盘驱动器 | /dev/sd[a-p]                                                                            |
| U盘                       | /dev/sd[a-p]（与SATA相同）                                                              |
| Virtio接口                | /dev/vd[a-p]（用于虚拟机内）                                                            |
| 软盘驱动器                | /dev/fd[0-7]                                                                            |
| 打印机                    | /dev/lp[0-2]（25针打印机）<br>/dev/usb/lp[0-2]（USB接口打印机）                         |
| 鼠标                      | /dev/input/mouse[0-15]（通用）<br> /dev/psaux（PS/2接口）<br>/dev/mouse（当前鼠标）     |
| CD-ROM、DVD-ROM           | /dev/scd[0-1]（通用）<br>/dev/sr[0-1]（通用，CentOS较常见）<br>/dev/cdrom（当前CD-ROM） |
| 磁带机                    | /dev/ht0（IDE接口）<br>/dev/st0（SATA/SCSI接口）<br>/dev/tape（当前磁带）               |
| IDE软盘驱动器             | /dev/hd[a-d]（旧系统才有）                                                              |


## 目录操作

### 目录切换命令

  - `cd /usr`: 切换到该目录下的usr目录

  - `cd .. (or cd ../)`: 切换到上一层目录

  - `cd /`: 切换到系统根目录

  - `cd ~`: 切换到用户主目录(也就是`/home`目录)

  - `cd -`: 切换到上一个操作所在目录

### 目录的增删改查
- **pwd: 显示当前目录**
  ```bash
  pwd [-p]
  # 选项与参数:
  # -P: 显示出确实的路径，而非使用链接(link)路径
  ```
- **mkdir: 新建目录**
  ```bash
  mkdir [-mp] 目录名 
  # 选项与参数:
  # -m: 配置文件权限
  # -p: 递归创建目录

  # 示例
  mkdir -p /test1/test2/test3
  mkdir -m 711 test2
  ```
- **rmdir: 删除空目录**
  ```bash
  rmdir [-p] 目录名
  # 选项与参数:
  # -p: 连同上层"空"目录一并删除

  # 示例
  mkdir -p /test1/test2/test3
  rmdir /test1/test2/test3 # 报错: Directory not empty
  rmdir -p /test1/test2/test3 # 成功
  ```
- **rm -r: 删除非空目录**
  ```bash
  rm -r 目录名
  ```
- **ls/ll: 查看目录信息**
  ```bash
  ls/ll [-aAdfFhilnrRSt] 目录名
  # 选项与参数:
  # -a: 显示所有文件，包括隐藏文件
  # -d: 显示目录本身的信息
  # -l: 以长格式显示文件信息
  # -R: 递归显示子目录
  # -S: 以文件大小排序
  # -t: 以修改时间排序
  ```

## 文件操作
### 文件的建立、移动与删除
- **touch : 建立空文件**
  ```bash
  touch 文件名
  ```
- **cp : 复制**
  ```bash
  cp [-adfilprsu] 源文件1 源文件2... 目标目录
  # 将源文件1、源文件2... 复制到目标目录下
  # 选项与参数:
  # -a: 相当于-pdr, 保留所有文件属性和递归复制目录
  # -d: 若源文件为文件，则复制链接文件属性而非文件本身
  # -f: 强制覆盖目标文件
  # -i: 若目标文件已存在，提示是否覆盖
  # -l: 复制链接文件
  # -p: 保留源文件的属性
  # -r: 递归复制
  # -s: 复制成链接文件, 即快捷方式文件
  # -u: 若目标文件比源文件旧，则覆盖
  ```
- **mv: 移动**
  ```bash
  mv [-fiu] 源文件 目标目录
  # 将源文件移动到目标目录下
  # 选项与参数:
  # -f: 强制覆盖目标文件
  # -i: 若目标文件已存在，提示是否覆盖
  # -u: 若目标文件比源文件旧，则覆盖
  ```
- **rm: 删除**
  ```bash
  rm [-fir] 文件名
  # 删除文件
  # 选项与参数:
  # -f: 强制删除
  # -i: 删除前提示
  # -r: 递归删除
  ```
### 查看文件内容
- 通用操作:
  - `空格键`: 向下翻页
  - `Enter键`: 向下滚动一行
  - `b`: 向上翻页
  - `/字符串`: 向下搜索字符串
  - `?字符串`: 向上搜索字符串
  - `q`: 退出
- **cat : 查看文件内容**
  ```bash
  cat [-AbEnTv] 文件名
  # 选项与参数:
  # -A: 显示所有字符
  # -E: 显示行尾的"$"
  # -n: 显示行号
  # -T: 制表符显示为"^I"
  # -v: 显示不可打印字符
  ```
- **more/less : 分页显示文件内容**
  ```bash
  more/less 文件名
  # more: 一页一页显示
  # less: 可以向前翻页
  ```
- **head : 显示文件开头n行内容**
  ```bash
  head [-n number] 文件名
  # 选项与参数:
  # -n: 显示文件的前number行
  ```
- **tail : 显示文件结尾n行内容**
  ```bash
  tail [-n number] 文件名
  # 选项与参数:
  # -n: 显示文件的后number行
  ```

### 文件的查找
- **可执行文件的查找**


  - `which`是根据`PATH`这个环境变量所规范的路径去查找执行文件的文件名
    ```bash
    # 查找命令的路径
    which [-a] 命令
    # -a : 将所有由PATH目录中可以找到的命令全列出来
    ```

  - `type`是用来区分命令是内建命令还是外部命令
    ```bash
    # 查找命令的类型
    type [-tpaf] 命令
    # -t: 显示命令的类型。file: 外部命令, alias: 别名, builtin: 内建命令
    # -p: 如果给出的参数是外部命令，则显示命令的绝对路径
    # -a: 显示命令所有的信息，包括别名、内置命令、函数等
    # -f: 只返回shell函数的信息
    ```

- **一般文件的查找**
  - **whereis-在特定的目录中查找文件**
    ```bash
    whereis [-bmsu] 文件或目录名
    # 选项与参数:
    # -b: 只查找二进制文件
    # -m: 只查找帮助文件
    # -s: 只查找源文件
    # -u: 查找不在默认路径中的文件

    > whereis ifconfig
    ifconfig: /sbin/ifconfig /usr/share/man/man8/ifconfig.8.gz

    ```
  - **locate-在数据库中搜索指定的文件**

    此数据库`/var/lib/locatedb`是Linux系统自动创建的，数据库中含有本地文件的所有信息，数据库由updatedb程序来自动更新
    ```bash
    locate [-ir] keyword
    # 选项与参数:
    # -c: 只计算找到的文件数量
    # -l: 后接数字，表示输出几行
    # -i: 忽略大小写
    # -r: 后面的字符串为正则表达式

    > locate -l 5 passwd
    /etc/passwd
    /etc/passwd-
    /etc/pam.d/passwd
    /etc/security/opasswd
    /usr/bin/gpasswd
    ```
  - **find-查找任何类型的文件**
    ```bash
    find [path] [option] [action]
    # 选项与参数:
    # -name: 按照文件名查找，支持通配符
    # -type: 按照文件类型查找(b: 块设备文件, c: 字符设备文件, d: 目录等)
    # -user: 按照文件属主查找
    # -group: 按照文件所属组查找

    # 示例: 查找/etc目录下所有名为passwd的文件
    > find /etc -name passwd
    /etc/passwd
    /etc/passwd-
    /etc/pam.d/passwd
    ```
## 权限相关
### 用户与用户组
在linux中，用户(User)和用户组(Group)是管理系统权限和资源访问的重要概念。
- **用户（User）**<br>
  用户是指系统中的一个身份标识，每个用户都有自己的用户名和密码。每个用户可以拥有自己的文件、进程和权限。
  - 创建用户
    ```bash
    # -m: 创建用户时创建对应的/home目录
    sudo useradd -m username
    ```
  - 删除用户
    ```bash
    sudo userdel username
    ```
  - 修改用户密码
    ```bash
    sudo passwd username
    ```
  - 修改用户属性
    ```bash
    sudo usermod [选项] username
    # 选项:
    # -l: 修改用户登录名
    # -g: 修改用户主组
    # -aG: 添加用户到附加组
    ```
  - 删除用户
    ```bash
    # -r: 删除用户的同时删除/home目录和邮件文件
    sudo userdel -r username
    ```

- **用户组(Group)**<br>
  用户组是指一组用户的集合，常用于授权管理和文件访问控制。每个用户可以属于多个用户组，每个用户组可以拥有多个用户。
  - 创建用户组
    ```bash
    sudo groupadd groupname
    ```
  - 修改用户组
    ```bash
    # -n: 修改用户组名
    sudo groupmod -n newgroupname oldgroupname
    ```
  - 删除用户组
    ```bash
    sudo groupdel groupname
    ```
  - 查看用户所属组
    ```bash
    groups username
    ```
  
- **其他常用命令**
  - 查看所有用户
    ```bash
    cat /etc/passwd
    ```
  - 查看所有用户组
    ```bash
    cat /etc/group
    ```
  - 切换用户
    ```bash
    su - username
    ```
  - 查看当前用户
    ```bash
    whoami
    ```
  - 查看用户详细信息
    ```bash
    id username
    ```

### 权限介绍
为了管理文件的访问权限，Linux使用读、写和执行三种权限
- **读权限 (r)**: 允许用户读取文件内容或查看目录中的文件列表
- **写权限 (w)**: 允许用户写入或删除文件，或在目录中创建、删除或重命名文件
- **执行权限 (x)**: 允许用户执行文件或进入目录

![权限对应关系](https://raw.githubusercontent.com/AliceSpring123/img/main/八进制对字符串.png){style="display:block;margin:auto"}

```bash
ls -l
# 输出示例
-rw-r--r-- 1 yc staff 1667 9 2 19:03 app.ts
```
每位含义:
  ![文件权限示例](https://raw.githubusercontent.com/AliceSpring123/img/main/文件权限示例.png){style="display:block;margin:auto"}

其中, 2~10位为权限位，分为三组，分别代表文件所有者，文件所属组， 其他人的权限:
![权限位示例](https://raw.githubusercontent.com/AliceSpring123/img/main/9位权限位.png){style="display:block;margin:auto"}

**rwx权限对文件的作用**

对于文件来说，执行权限是最高权限
<table>
<thead>
  <tr>
    <td width="120">rwx权限</td>
    <td>描述</td>
  </tr>
</thead>
<tbody>
  <tr>
    <td style="word-wrap: break-word;">读权限(r)</td>
    <td style="word-wrap: break-word;">表示可读取此文件中的实际内容，例如，可以对文件执行cat、more、less、head、tail等文件查看命令</td>
  </tr>
  <tr>
  <td style="word-wrap: break-word;">写权限(w)</td>
    <td style="word-wrap: break-word;">表示可以编辑、新增或修改文件中的内容，例如，可以对文件执行vim、echo等修改文件数据的命令。注意，写权限不赋予用户删除文件的权力，除非用户对文件的上级目录拥有写权限才可以</td>
  </tr>
  <tr>
  <td style="word-wrap: break-word;">执行权限(x)</td>
    <td style="word-wrap: break-word;">表示该文件具有被系统执行的权限<br>但是，文件是否能正确执行，还要看文件中的代码是否正确</td>
  </tr>
</tbody>
</table>

**rwx权限对目录的作用**
<table>
<thead>
  <tr>
    <td width="120">rwx权限</td>
    <td>描述</td>
  </tr>
</thead>
<tbody>
  <tr>
    <td style="word-wrap: break-word;">读权限(r)</td>
    <td style="word-wrap: break-word;">表示具有读取目录结构列表的权限，也就是说，可以看到目录中有哪些文件和子目录。一旦对目录拥有 r 权限，就可以在此目录下执行 ls 命令，查看目录中的内容</td>
  </tr>
  <tr>
  <td style="word-wrap: break-word;">写权限(w)</td>
    <td style="word-wrap: break-word;">对于目录来说，w 权限是最高权限。对目录拥有 w 权限，表示可以对目录做以下操作：在此目录中建立新的文件或子目录；删除已存在的文件和目录（无论子文件或子目录的权限是怎样的）；对已存在的文件或目录做更名操作；移动此目录下的文件和目录的位置。一旦对目录拥有 w 权限，就可以在目录下执行 touch、rm、cp、mv 等命令</td>
  </tr>
  <tr>
  <td style="word-wrap: break-word;">执行权限(x)</td>
    <td style="word-wrap: break-word;">目录是不能直接运行的，对目录赋予 x 权限，代表用户可以进入目录，也就是说，可以使用 cd 命令。</td>
  </tr>
</tbody>
</table>

### 变更文件权限

**chmod 命令**
```bash
chmod [参数] [[角色][赋值权限][权限],…] 文件名
```

参数:
<table>
<thead>
  <tr>
    <td width="120">参数</td>
    <td width="240">描述</td>
  </tr>
</thead>
<tbody>
  <tr>
    <td style="word-wrap: break-word;">-R</td>
    <td style="word-wrap: break-word;">递归处理，将指定目录下的所有文件及子目录一并处理</td>
  </tr>
  <tr>
    <td style="word-wrap: break-word;">-c</td>
    <td style="word-wrap: break-word;">显示更改的部分的信息</td>
  </tr>
  <tr>
    <td style="word-wrap: break-word;">-f</td>
    <td style="word-wrap: break-word;">忽略错误信息</td>
  </tr>
  <tr>
    <td style="word-wrap: break-word;">-v</td>
    <td style="word-wrap: break-word;">显示详细的处理信息</td>
  </tr>
</tbody>
</table>

角色: 
```bash
u: user, 文件所有者

g: group, 文件所属组

o: others, 其他人

a: all, 所有人
```

赋值权限:
```bash
+ : 添加权限

- : 删除权限

= : 赋予唯一权限
```

示例:
```bash
# 手动对角色增减权限
chmod -R u+x,g-wx,o=r test.txt

# 使用八进制权限法，对 <所有者、群组、其他人>赋值权限
chmod -R 764 test.txt #设置权限值为 rwxrw-r--
```

### 变更文件的所属组

**chgrp 命令**
```bash
chgrp [-R] 所属组 文件名
# -R: 递归处理，将指定目录下的所有文件及子目录一并处理
```
示例:
```bash
chgrp -R test_group ./test # 将test的所属组变更为test_group组
```

### 变更文件所有者与所属组

**chown 命令**
```bash
chown [参数] [所有者:所属组] 文件名
```
参数:
<table>
<thead>
  <tr>
    <td width="120">参数</td>
    <td width="240">描述</td>
  </tr>
</thead>
<tbody>
  <tr>
    <td style="word-wrap: break-word;">-R</td>
    <td style="word-wrap: break-word;">递归处理，将指定目录下的所有文件及子目录一并处理</td>
  </tr>
  <tr>
    <td style="word-wrap: break-word;">-c</td>
    <td style="word-wrap: break-word;">显示更改的部分的信息</td>
  </tr>
  <tr>
    <td style="word-wrap: break-word;">-f</td>
    <td style="word-wrap: break-word;">忽略错误信息</td>
  </tr>
  <tr>
    <td style="word-wrap: break-word;">-v</td>
    <td style="word-wrap: break-word;">显示详细的处理信息</td>
  </tr>
</tbody>
</table>

示例:
```bash
chown -R test_user:test_group ./test # test_user用户、test_group组
```

## 文件隐藏属性
文件的隐藏属性对系统安全非常的重要
### 查看文件隐藏属性-lsattr 
```bash
lsattr [-adR] 文件或目录
# -a: 显示隐藏文件
# -d: 如果查看的是目录，仅列出目录本身的属性而非目录内的文件名
# -R: 递归显示
```
### 配置文件隐藏属性-chattr
```bash
chattr [+-=] [ASacdistu] 文件或目录
# 选项与参数:
# +: 添加属性
# -: 删除属性
# =: 设置属性
# A: 固定文件的存取时间，当发生新的存取操作时，存取时间atime不会被更新
# S: 当进行任何的文件修改，该修改会立即同步写入磁盘中
# a: 只允许在文件中增加数据，不允许删除和修改数据，只允许root设置
# c: 自动压缩文件，在读取时会自动解压缩，存储时先压缩在存储
# d: 不会被dump备份程序备份
# i: 不允许对文件进行删除、改名、链接、写入等操作，只允许root设置
# s: 保密性删除，文件被删除后，文件内容被擦除，不可恢复
```

示例:
```bash
chattr +i test.txt # 设置test.txt文件为只读文件，不可被删除、改名、链接、写入
chattr -i test.txt # 取消test.txt文件的只读属性
```

## 打包与压缩
### 名词解释
**打包**: 也成为归档，是将多个文件或目录合并成一个文件的过程。_打包后的文件没有经过压缩，它占用的空间是其中所有文件或目录的总和_。

**压缩**: 是将一个或多个文件或目录经过压缩算法处理后，生成一个压缩文件。_不能直接压缩目录，需要先打包目录，才能压缩打包后的目录_。

### 打包与解打包
**打包**

使用`tar`命令打包的包通常称为`tar包`。(以`.tar`结尾)
```bash
tar [选项] 源文件或目录
```
<table>
<thead>
  <tr>
    <td width="100">选项</td>
    <td>描述</td>
  </tr>
</thead>
<tbody>
  <tr>
    <td>-c</td>
    <td>将多个文件或目录进行打包</td>
  </tr>
  <tr>
    <td>-v</td>
    <td>显示打包文件过程</td>
  </tr>
  <tr>
    <td>-f 包名</td>
    <td>指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名</td>
  </tr>
  <tr>
    <td>-A</td>
    <td>追加 tar 文件到归档文件</td>
  </tr>
</tbody>
</table>

一般习惯用法是使用选项"`-cvf`"
```bash
tar -cvf test.tar test.txt # 将test.txt文件打包成test.tar
```
也可以打包多个文件和目录, 以空格分隔
```bash
tar -cvf test.tar test.txt test2.txt test_dir 
# 将test.txt、test2.txt、test_dir一并打包成test.tar
```

**解打包**
解开的包只能是`.tar`包
```bash
tar [选项] 需要解包的包名 #.tar为后缀
```
<table>
<thead>
  <tr>
    <td width="100">选项</td>
    <td>描述</td>
  </tr>
</thead>
<tbody>
  <tr>
    <td>-x</td>
    <td>解包</td>
  </tr>
  <tr>
    <td>-v</td>
    <td>显示解包过程</td>
  </tr>
  <tr>
    <td>-f 包名</td>
    <td>指定需要解包的包文件名</td>
  </tr>
  <tr>
    <td>-t</td>
    <td>只查看tar包中有哪些文件或目录，不对tar包做解打包操作</td>
  </tr>
  <tr>
    <td>-C 目录</td>
    <td>指定解包的目录, 默认当前目录</td>
  </tr>
</tbody>
</table>

一般习惯用法是使用选项"`-xvf`"
```bash
tar -xvf a.tar #解包到当前目录

tar -xvf a.tar -C /tmp #指定解包后，输出到/tmp目录
```

另一种用法是使用选项"-tvf"
```bash
tar -tvf a.tar #会用长格式显示a.tar文件包中文件的详细信息

##比如：
#  -rw-r-r- root/root 0 2022-05-1 8:00 b.txt 
#  -rw-r-r- root/root 0 2022-05-2 8:00 c.cpp
```

### 压缩与解压缩
上面我们说了目录不能直接压缩，需要先打包在压缩，但是在tar命令中只需要再加入一个参数就可以打包后直接压缩/解压了

- **打包并压缩**
  - 使用gzip压缩
    ```bash
    # 将file1 file2打包并压缩成test.tar.gz
    tar -zcvf test.tar.gz file1 file2
    ```
  - 使用bzip2压缩
    ```bash
    # 将file1 file2打包并压缩成test.tar.bz2
    tar -jcvf test.tar.bz2 file1 file2
    ```
  - 使用xz压缩
    ```bash
    # 将file1 file2打包并压缩成test.tar.xz
    tar -Jcvf test.tar.xz file1 file2
    ```
- **解压并解包**
  - 解压.tar.gz文件
    ```bash
    tar -zxvf test.tar.gz -C /tmp
    # 将test.tar.gz解压到/tmp目录
    ```
  - 解压.tar.bz2文件
    ```bash
    # 将test.tar.bz2解压到/tmp目录
    tar -jxvf test.tar.bz2 -C /tmp
    ```
  - 解压.tar.xz文件
    ```bash
    # 将test.tar.xz解压到/tmp目录
    tar -Jxvf test.tar.xz -C /tmp
    ```

## Bash
Bash是Linux系统中最常用的shell，是一个命令处理器，通常执行于文字窗口中，用于自动化执行一系列命令。
### 查询命令是否为Bash内建命令
```bash
type [-tpaf] command
# -t: 显示命令的类型。
#     file: 外部命令
#     alias: 别名
#     builtin: 内建命令
# -p: 如果命令是外部命令，则显示命令的绝对路径
# -a: 会由PATH变量定义的路径中显示命令所有的信息，包括别名、内置命令、函数等
# -f: 只返回shell函数的信息
```
### 命令的快速编辑
当输入的命令特别长,或输入了一串错误的命令时,可以使用快速编辑功能来快速修改命令:
- `Ctrl + a`: 将光标移动到命令行的开头
- `Ctrl + e`: 将光标移动到命令行的结尾
- `Ctrl + u`: 删除光标前的所有字符
- `Ctrl + k`: 删除光标后的所有字符

### 变量
- **变量的使用与设置**
  - **变量的使用**
    ```bash
    # 使用echo来使用变量
    echo $变量名\${变量名}

    # 注意:变量在被使用时,前面需要加上"$"符号或以"${}"包裹
    # 例
    echo $PATH
    /usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
    ```
  - **变量的设置规则**
    - 变量与值之间以 `=` 连接, 等号两边不能有空格
    - 变量名称只能是英文字母或数字, 且不能以数字开头
    - 变量内容如果有空格, 需要使用单引号或双引号包裹
    - 单引号与双引号必须成对, 如变量值中包含单引号, 则使用双引号包裹,反之亦然
    - 双引号内的`$变量`会被解析, 单引号内的`$变量`不会被解析
    - 若变量需要在其他子程序执行, 则需要 `export 变量名` 来使变量变成环境变量
    - 通常大写字符表示系统默认变量, 小写字符表示用户变量
  - **变量的取消**
  ```bash
  unset 变量名
  ```

- **查看变量**
  ```bash
  # 查看环境变量
  env
  # 查看所有变量
  set
  ```

- **变量的读取**

  - 读取键盘输入<br>
  要读取来自键盘输入的变量,就是用`read`命令,这个命令常被用于脚本中, 用于跟用户交互
    ```bash
    read [-p 提示信息] [-t 超时时间] [-s] 变量名
    # -p: 提示信息
    # -t: 后面接秒数,表示等待输入的时间
    # -s: 隐藏输入

    # 示例:
    read -p "请输入你的名字:" -s 30 name
    请输入你的名字: Eric      # 此时光标会等待你30s

    echo "你的名字是$name"
    你的名字是Eric
    ```

- **变量的声明**
使用`declear`或`typeset`命令来声明变量的类型
  ```bash
  declear [-aixrp] 变量名

  # -a: array, 将变量声明为数组
  # -i: int, 将变量声明为整数
  # -x: 将变量声明为环境变量(全局变量), 用法与export相同
  # -r: 将变量声明为只读变量,该变量不可被更改内容,也不可被unset
  # -p: 显示变量名与类型
  ```
  注意: 
  - 变量名默认为字符串,所以若不指定变量类型,则`sum=1+2`中的sum是字符串"`1+2`",而不是3,当使用`declare -i sum=1+2`来声明`sum`为整数后,`sum`才等于`3`
  - bash环境中的数值运算默认支持到整数,所以`1\3`结果是`0`

### 限制用户的系统资源
bash可以限制用户的某些系统资源，包括可以开启的文件数量，可以使用的CPU时间，可以使用的内存大小等
```bash
ulimit [-SHacdfltu] [配额]
# -H: hard limit 硬性限制, 必定不能超过设置的值
# -S: soft limit 软性限制, 可以超过设置的值, 但超过后会收到警告，
#     在设置上，通常soft会比hard小, soft可以设置80,hard设置100
#     这样用户可以使用80~100，超过80后会收到警告
# -a: 后面不接任何选项与参数, 可列出所有的限制额度
# -c: 当某些程序发生错误时, 系统可能会将该程序在内存中的信息写成文件, 
#     这种文件就被称为内核文件(core file)。 此为设置core file的最大值
# -d: 设置程序可使用的最大段内存容量
# -f: 此shell可以开启的最大文件容量, 一般可能设置为2GB, 单位为kbytes
# -l: 可用于锁定的内存量
# -t: 可使用的最大CPU时间, 单位为秒
# -u: 设置单一用户可使用的最大进程数
```

### 命令别名
`alias`命令可以用来设置命令别名, 用于简化复杂命令
```bash
# 设置命令别名
alias 别名='原命令'  

# 取消命令别名
unalias 别名       

# 显示所有命令别名
alias              

# 示例:
alias ll='ls -l'
alias rm='rm -i'
```

### 历史命令
bash会记录用户执行过的命令, 并按执行时间顺序将命令记录在`~/.bash_history`文件中, 使用`history`命令可以显示用户执行过的命令
```bash
# n为数字，列出最近n条命令
history [n]

# 清除历史命令
history -c

# 读取.bash_history文件中的历史命令
history -r

# 将历史命令写入.bash_history文件
history -w
```

### 登录与欢迎信息
bash的登录与欢迎信息存放在/etc/issue文件中, 可以使用`cat`命令查看
```bash
cat /etc/issue
```

issue内各代码的意义:
| 代码 | 意义 |
| --- | --- |
| `\d` | 显示日期 |
| `\t` | 显示时间 |
| `\l` | 显示第几个终端页面 |
| `\m` | 显示硬件等级 |
| `\n` | 显示主机的网络名称 |
| `\r` | 显示操作系统版本 |
| `\S` | 显示操作系统名称 |


自定义欢迎页面示例:
```bash
# 在/etc/issue文件中添加以下内容
\S (terminal: \l)
Date: \d \t
Kernel: \r on \m
welcome!
```
示例效果
```bash
Ubuntu 20.04 (terminal: tty1)
Date: 2022-05-1 8:00
Kernel: 5.4.0-42-generic on x86_64
welcome!
[root@localhost ~]#
```

### 环境配置文件

- **login shell**<br>
  login shell是取得bash时需要登陆的shell

  在login shell中, 会读取以下配置文件:
  - `/etc/profile`: 系统的整体设置
  - `/etc/profile.d`: 系统整体设置的辅助文件
  - `~/.bash_profile`: login shell下用户自定义的配置文件
  - `~/.bashrc`: 被`~/.bash_profile`读取的配置文件

![login shell的配置文件读取流程](https://raw.githubusercontent.com/AliceSpring123/img/main/bash配置文件1.gif)

- **non-login shell**<br>
  non-login shell是取得bash时不需要登陆的shell，在non-login shell中， 仅会读取 `~/.bashrc`配置文件:

- **读入环境配置文件**
  ```bash
  # 读入环境配置文件
  source 配置文件名

  # 示例
  source ~/.bashrc
  ``` 

### 通配符与特殊符号
一些常用的通配符:
| 通配符 | 意义 |
| --- | --- |
| `*` | 代表0个或多个字符 |
| `?` | 代表一个字符 |
| `[list]` | 代表list中的任何一个字符, 如[abcd]代表a、b、c、d中的任意一个 |
| `[^list]` | 代表除list中的字符以外的字符 |

一些常用的特殊符号:
| 符号 | 意义 |
| --- | --- |
| `#` | 注释符号, 在`#`后面加上的内容会被视为注释 |
| `\` | 转义符, 将特殊符号或通配符的特殊意义去除 |
| `\|` | 管道符号, 将前一个命令的标准输出作为后一个命令的标准输入 |
| `;` | 连续命令执行分隔符 |

### 数据流重定向
数据流重定向是将某个命令执行后应该出现在屏幕上的数据, 给他传输到其他地方, 常见的数据流有**标准输入**、**标准输出**、**标准错误输出**

- **重定向符号**
  - 标准输入(stdin): 代码为 `0`, 符号为: `<` 或 `<<`
  - 标准输出(stdout): 代码为 `1`, 符号为: `>` 或 `>>`
  - 标准错误输出(stderr): 代码为 `2`, 符号为: `2>` 或 `2>>`

- **标准输出(stdout)和标准错误输出(stderr)**<br>
  - 标准输出: 命令执行后, 将正确信息输出到屏幕上
  - 标准错误输出: 命令执行后, 将报错信息输出到屏幕上


```bash
# 示例
# 将标准输出重定向到文件
# 若newfile文件不存在, 则创建newfile, 若存在, 则全部覆盖
ls -l /etc/passwd > ~/newfile

# 若newfile文件不存在, 则创建newfile, 若存在, 则追加到末尾
ls -l /etc/passwd >> ~/newfile

# 将标准错误输出重定向到文件
# 若newfile文件不存在, 则创建newfile, 若存在, 则全部覆盖
ls -l /etc/passwd 2> ~/newfile

# 若newfile文件不存在, 则创建newfile, 若存在, 则追加到末尾
ls -l /etc/passwd 2>> ~/newfile
```

```bash
# 示例2
# 若同时存在标准输出和标准错误输出

# 1. 将标准输出和标准错误输出通通重定向到一个文件
ls -l /etc/passwd > ~/newfile 2>&1

# 2. 将标准输出重定向到文件file_a, 将标准错误输出重定向到file_b
ls -l /etc/passwd > file_a 2> file_b

```

- **标准输入(stdin)**<br>
  标准输入的用途: 将原本需要由键盘输入的数据，改由文件内容来输入
  ```bash
  # 示例
  # 将"Jack"写入file文件
  echo "Jack" > file

  # 将file文件内容作为标准输入
  read name < file
  echo $name    # 输出Jack
  ```
  使用符号`<<`的意思是: 将标准输入重定向到文件, 直到遇到`<<`后面的内容为止
  ```bash
  # 作用是将两个 分界符 之间的内容(document) 作为输入传递给 command。
  command << 分界符
  内容(document)
  分界符

  # 示例
  cat << "EOF"
  hello
  world
  EOF # 当遇到EOF时, 将hello \n world作为输入传递给cat命令

  # 输出:
  hello
  world
  ```

### 多条命令执行方式
若一个命令执行结果为正确，在Linux下面会返回一个`$?=0`的值，若执行结果为错误，则返回`$?!=0`的值。根据此特性，若我们想一次性执行很多命令，可以使用`;`或`&&`或`||`来连接多个命令

| 符号 | 意义 |
| --- | --- |
| `cmd1 ; cmd2` | 不管前面的命令是否执行成功，都会执行后面的命令 |
| `cmd1 && cmd2` | 只有在前面的命令执行成功后(`$?=0`)，才会接着执行后面的命令 |
| `cmd1 \|\| cmd2` | 只有在前面的命令执行失败后(`$?!=0`)，才会接着执行后面的命令 |



### 管道命令
管道命令的格式为`cmd1 | cmd2`，表示将`cmd1`的输出作为`cmd2`的输入。管道命令的执行顺序为:

- 管道命令仅会处理标准输出，对于标准错误输出会忽略
- 管道命令必须要能够接受来自前一个命令的标准输出作为标准输入继续处理
- 管道命令连接的命令，其执行顺序为从左到右

### 选取命令

- **`cut` 命令**<br>
  `cut`命令可以讲一段信息的某一段"切"出来，处理信息时以**行**为单位

  ```bash
  cut -d '分隔符' -f 段落 # 用于有特定分隔符的场景
  cut -c 字符范围 # 用于没有特定分隔符的场景
  # 选项与参数:
  # -d: 后面接分隔字符, 与-f一起使用
  # -f: 后接数字, 根据-d的分隔字符将一段信息分割成数个片段, 
  #     从第一个开始, 数字表示第几个片段
  # -c: 以字符为单位进行分割, 后面接数字, 代表第几个字符开始切割


  # 示例1:将PATH中的环境变量进行分割
  echo ${PATH}
  /usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games

  echo ${PATH} | cut -d ':' -f 1
  /usr/local/bin

  echo ${PATH} | cut -d ':' -f 1,3
  /usr/local/bin:/usr/bin
  
  echo ${PATH} | cut -d ':' -f 1-3
  /usr/local/bin:/usr/sbin:/usr/bin


  # 示例2: 将export输出的信息, 取得第12个字符以后的所有字符
  $ export
  declare -x PATH="/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games"
  declare -x PS1="[\u@\h \w \A \n \t]"
  declare -x USER="root"
  declare -x PWD="/root"
  declare -x HOME="/root"
  declare -x LOGNAME="root"

  $ export | cut -c 12-
  PATH="/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games"
  PS1="[\u@\h \w \A \n \t]"
  USER="root"
  PWD="/root"
  HOME="/root"
  LOGNAME="root"
  ```

- **`grep` 命令**<br>
  `grep`命令用于按行分析信息，当某一行中有我们需要的信息，就将该行拿出来，处理信息时也以**行**为单位

  ```bash
  grep [-acinv] [--color=auto] '查找字符' 文件名
  # 选项与参数:
  # -a: 将二进制文件以文本文件的方式查找数据
  # -c: 计算找到'查找字符'的行数
  # -i: 忽略大小写
  # -n: 输出行号
  # -v: 反向选择, 即显示没有'查找字符'的行
  # --color=auto: 将找到的关键字部分加上颜色显示
  ```

### 排序命令

- **`sort` 命令**<br>
  `sort`命令可以根据不同的数据形式来排序

  ```bash
  sort [-fbMnrtuk] [file or stdin ...]
  # 选项与参数:
  # -f: 忽略大小写
  # -b: 忽略最前面的空格符
  # -M: 以月份的名字来排序
  # -n: 使用纯数字进行排序
  # -r: 反向排序
  # -t: 分隔符, 默认是以空格符分隔
  # -u: 排序后, 相同的行只显示一次
  # -k: 指定排序的列
  ```
- **`wc` 命令**<br>
  `wc`命令用于计算文本文件的行数、字数、字节数

  ```bash
  wc [-lwm] [file ...]
  # 选项与参数:
  # -l: 仅列出行数
  # -w: 仅列出多少字(英文)
  # -m: 仅列出多少字符
  ```

- **`uniq` 命令**<br>
  `uniq`命令用于去除重复的行
  ```bash
  uniq [-ic]
  # 选项与参数:
  # -i: 忽略大小写
  # -c: 进行计数
  ```

### 字符转换命令

- **`tr` 命令**<br>
  `tr`命令可以用来删除一段信息当中的文字，或是进行文字信息的替换

  ```bash
  tr [-ds] SET1 ...
  # 选项与参数:
  # -d: 删除信息当中的SET1字符
  # -s: 替换掉重复的字符

  # 示例
  # 将小写转换为大写
  echo "hello" | tr '[a-z]' '[A-Z]'
  HELLO

  # 将连续重复的字符删除
  echo "hello" | tr -s 'l'
  helo
  ```

- **`col` 命令**<br>
  `col`命令可以用来将一段信息中的`tab`键转换为空格键

  ```bash
  col [-x]
  # 选项与参数:
  # -x: 将tab转换为空格
  ```

- **`join` 命令**<br>
  `join`命令用于将两个文件中，**有相同数据的那一行**合并在一起

  ```bash
  join [-ti12] file1 file2
  # 选项与参数:
  # -t: 指定分隔符, 默认以空格为分隔符
  # -i: 忽略大小写
  # -1: 第一个文件要用哪个栏位来分析
  # -2: 第二个文件要用哪个栏位来分析
  ```

- **`paste` 命令**<br>
  `paste`命令用于将两个文件中的内容合并在一起

  ```bash
  paste [-d] file1 file2
  # 选项与参数:
  # -d: 指定分隔符, 默认以空格为分隔符
  ```

- **`expand` 命令**<br>
  `expand`命令用于将tab转换为空格

  ```bash
  expand [-t] file
  # 选项与参数:
  # -t: 指定tab的空格数
  ```

### 划分命令

- **`split` 命令**<br>
  `split`命令用于将一个文件根据文件大小或行数来划分成数个文件

  ```bash
  split [-bl] file [prefix]
  # 选项与参数:
  # -b: 指定每个文件的大小，可加单位如b, k、m等
  # -l: 指定每个文件的行数
  # -prefix: 指定文件名前缀
  ```

